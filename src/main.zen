const std = @import("std");
const File = std.fs.File;
const heap = std.heap;
const os = std.os;
const ArrayList = std.container.ArrayList;
const ChildProcess = std.process.ChildProcess;

pub fn main() void {
    var fuzzer = Fuzzer.new();
    while (true) {
        fuzzer.genFuzz();
            std.debug.warn("hoge : {}\n", fuzzer.fuzz);
        const ret_code = fuzzer.doFuzz();
            std.debug.warn("huga : {}\n", fuzzer.fuzz);
        if (ret_code == 0) {
            fuzzer.dump(ret_code);
        }
    }
}

const Fuzzer = struct {
    const Self = @This();

    fuzz: []u8,
    log_file: File,

    pub fn new() Fuzzer {
        var file = File.openWrite("./dump.csv") catch |err| {
            std.debug.panic("not open file : {}\n", err);
        };
        return Fuzzer{
            .log_file = file,
            .fuzz = &"",
        };
    }

    pub fn genFuzz(self: *Self) void {
        //ランダム文字列で埋めるための準備
        const DefaultPrng = std.rand.DefaultPrng;
        var buf: [8]u8 = undefined;
        std.crypto.randomBytes(buf[0..]) catch |err| {
            std.debug.panic("not open file : {}\n", err);
        };

        const seed = std.mem.readIntNative(u64, &buf);

        var r = DefaultPrng.init(seed);

        var holder: [99]u8 = undefined;

        // アロケータの準備
        var bytes: [1024]u8 = undefined;
        var allocator = heap.FixedBufferAllocator{ .buffer = bytes[0..] };

        // `usize`を格納するArrayListの初期化。`deinit`でメモリを解放
        var list = ArrayList(usize){ .allocator = &allocator };
        defer list.deinit();

        std.rand.bytes(&r, &holder);

        var tmp_holder = genStr(&holder);
        var new_holder = tmp_holder.toSlice();
        self.fuzz = new_holder;
    }

    pub fn doFuzz(self: Self) u32 {
        if (self.fuzz.len == 0) {
            return 0;
        }
        const argv = &[_][]const u8{"ls", self.fuzz};

        const result = ChildProcess.exec(&heap.c_allocator, argv, null, null, 4096) catch |err| {
            std.debug.panic("can not process.exec : {}\n", err);
        };
        std.debug.warn("piyo : {}\n", self.fuzz);

        switch (result.term) {
            .Exited => return result.term.Exited,
            .Signal => return result.term.Signal,
            .Stopped => return result.term.Stopped,
            .Unknown => return result.term.Unknown,
        }
    }

    pub fn dump(self: Self, ret_code: u32) void {
        var buf: [1024]u8 = undefined;
        const status_code = std.fmt.bufPrint(&buf, "{d}", ret_code) catch |err| {
            std.debug.panic("can not bufPrint : {}\n", err);
        };

        const output = std.mem.concat(&heap.c_allocator, u8, [_][]const u8{ status_code, ",", self.fuzz, "\n" }) catch |err| {
            std.debug.panic("can not mem.concat : {}\n", err);
        };

        self.log_file.write(output) catch |err| {
            std.debug.panic("not write to file : {}\n", err);
        };
    }

    fn genStr(holder: []u8) ArrayList(u8) {
        // アロケータの準備
        var bytes: [1024]u8 = undefined;
        var allocator = heap.FixedBufferAllocator{ .buffer = bytes[0..] };
        // `u8`を格納するArrayListの初期化。`deinit`でメモリを解放
        var list = ArrayList(u8){ .allocator = &allocator };

        for (holder) |value| {
            switch (value) {
                0x21 => {
                    list.append(value) catch |err| {
                        std.debug.panic("not write to file : {}\n", err);
                    };
                },
                0x22 => {
                    list.append(value) catch |err| {
                        std.debug.panic("not write to file : {}\n", err);
                    };
                },
                0x23 => {
                    list.append(value) catch |err| {
                        std.debug.panic("not write to file : {}\n", err);
                    };
                },
                0x24 => {
                    list.append(value) catch |err| {
                        std.debug.panic("not write to file : {}\n", err);
                    };
                },
                0x25 => {
                    list.append(value) catch |err| {
                        std.debug.panic("not write to file : {}\n", err);
                    };
                },
                0x26 => {
                    list.append(value) catch |err| {
                        std.debug.panic("not write to file : {}\n", err);
                    };
                },
                0x27 => {
                    list.append(value) catch |err| {
                        std.debug.panic("not write to file : {}\n", err);
                    };
                },
                0x28 => {
                    list.append(value) catch |err| {
                        std.debug.panic("not write to file : {}\n", err);
                    };
                },
                0x29 => {
                    list.append(value) catch |err| {
                        std.debug.panic("not write to file : {}\n", err);
                    };
                },
                0x7E => {
                    list.append(value) catch |err| {
                        std.debug.panic("not write to file : {}\n", err);
                    };
                },
                else => {},
            }
        }
        return list;
    }
};
